#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from nav_msgs.msg import OccupancyGrid, Path, Odometry
from geometry_msgs.msg import PoseStamped
import numpy as np
import heapq

class AStarPlanner:
    def __init__(self, grid):
        self.grid = grid
        self.height, self.width = grid.shape

    def neighbors(self, node):
        x, y = node
        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < self.width and 0 <= ny < self.height:
                if self.grid[ny][nx] == 0:
                    yield (nx, ny)

    def heuristic(self, a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def plan(self, start, goal):
        frontier = [(0, start)]
        came_from = {start: None}
        cost_so_far = {start: 0}

        while frontier:
            _, current = heapq.heappop(frontier)
            if current == goal:
                break
            for next_node in self.neighbors(current):
                new_cost = cost_so_far[current] + 1
                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                    cost_so_far[next_node] = new_cost
                    priority = new_cost + self.heuristic(goal, next_node)
                    heapq.heappush(frontier, (priority, next_node))
                    came_from[next_node] = current

        path = []
        node = goal
        while node and node in came_from:
            path.append(node)
            node = came_from[node]
        path.reverse()
        return path

class PathPlannerNode(Node):
    def __init__(self):
        super().__init__('path_planner')
        self.map = None
        self.map_info = None
        self.robot_pose = None
        self.goal_pose = None

        self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10)
        self.create_subscription(Odometry, '/odom', self.odom_callback, 10)
        self.create_subscription(PoseStamped, '/goal_pose', self.goal_callback, 10)
        self.path_pub = self.create_publisher(Path, '/plan', 10)

    def map_callback(self, msg):
        self.map_info = msg.info
        width = msg.info.width
        height = msg.info.height

        if width == 0 or height == 0 or msg.info.resolution == 0.0:
            self.get_logger().warn("‚ùó Mapa recibido inv√°lido")
            return

        data = np.array(msg.data).reshape((height, width))
        self.map = np.where(data > 50, 1, 0)

    def odom_callback(self, msg):
        self.robot_pose = msg.pose.pose

    def goal_callback(self, msg):
        self.goal_pose = msg.pose
        self.try_plan()

    def try_plan(self):
        if self.map is None or self.robot_pose is None or self.goal_pose is None:
            self.get_logger().info("‚è≥ Esperando mapa, posici√≥n y objetivo...")
            return

        def world_to_map(x, y):
            mx = int((x - self.map_info.origin.position.x) / self.map_info.resolution)
            my = int((y - self.map_info.origin.position.y) / self.map_info.resolution)
            return mx, my

        start = world_to_map(self.robot_pose.position.x, self.robot_pose.position.y)
        goal = world_to_map(self.goal_pose.position.x, self.goal_pose.position.y)

        if not (0 <= start[0] < self.map.shape[1] and 0 <= start[1] < self.map.shape[0]):
            self.get_logger().warn("‚ö†Ô∏è Posici√≥n inicial fuera del mapa")
            return
        if not (0 <= goal[0] < self.map.shape[1] and 0 <= goal[1] < self.map.shape[0]):
            self.get_logger().warn("‚ö†Ô∏è Objetivo fuera del mapa")
            return

        self.get_logger().info(f'üìç Start: {start}, üèÅ Goal: {goal}')
        planner = AStarPlanner(self.map)
        path = planner.plan(start, goal)

        if not path or len(path) < 2:
            self.get_logger().warn("‚ùå No se pudo encontrar un camino")
            return

        path_msg = Path()
        path_msg.header.frame_id = "map"
        path_msg.header.stamp = self.get_clock().now().to_msg()

        for x, y in path:
            pose = PoseStamped()
            pose.header = path_msg.header
            pose.pose.position.x = x * self.map_info.resolution + self.map_info.origin.position.x
            pose.pose.position.y = y * self.map_info.resolution + self.map_info.origin.position.y
            pose.pose.orientation.w = 1.0
            path_msg.poses.append(pose)

        self.path_pub.publish(path_msg)
        self.get_logger().info(f'‚úÖ Ruta A* publicada con {len(path)} puntos')

def main(args=None):
    rclpy.init(args=args)
    node = PathPlannerNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
if __name__ == '__main__':
    main()